#!/usr/bin/env -S deno run --allow-read --allow-run --allow-net --allow-env

interface RouteConfig {
  path: string;
  method: string;
  command: string[];
  data?: Record<string, string>;
}

interface ServerConfig {
  port: number;
  runAsRoot: boolean;
  routes: RouteConfig[];
}

// Load configuration from JSON file generated by NixOS
async function loadConfig(): Promise<ServerConfig> {
  try {
    const configText = await Deno.readTextFile("/etc/lanserver/config.json");
    return JSON.parse(configText);
  } catch (error) {
    console.error("Failed to load config:", error);
    Deno.exit(1);
  }
}

// Execute each command string as a complete shell command
async function executeCommands(
  commands: string[],
  env: Record<string, string> = {},
): Promise<{ success: boolean; outputs: string[]; errors: string[] }> {
  const outputs: string[] = [];
  const errors: string[] = [];
  let allSuccessful = true;

  for (const commandString of commands) {
    try {
      // Use bash instead of sh - bash should be available in PATH for systemd services
      const cmd = new Deno.Command("bash", {
        args: ["-c", commandString],
        env: { ...Deno.env.toObject(), ...env },
        stdout: "piped",
        stderr: "piped",
      });

      const { code, stdout, stderr } = await cmd.output();

      const output = new TextDecoder().decode(stdout);
      const error = new TextDecoder().decode(stderr);

      outputs.push(output);
      errors.push(error);

      if (code !== 0) {
        allSuccessful = false;
        console.error(`Command failed (exit code ${code}): ${commandString}`);
        console.error(`Error: ${error}`);
      } else {
        console.log(`Command succeeded: ${commandString}`);
        if (output) console.log(`Output: ${output.trim()}`);
      }
    } catch (error) {
      allSuccessful = false;
      const errorMsg = `Command execution failed: ${error.message}`;
      outputs.push("");
      errors.push(errorMsg);
      console.error(`Failed to execute: ${commandString} - ${errorMsg}`);
    }
  }

  return {
    success: allSuccessful,
    outputs,
    errors,
  };
}

// Parse request body for POST requests
async function parseRequestData(req: Request): Promise<Record<string, string>> {
  if (req.method !== "POST" || !req.body) {
    return {};
  }

  try {
    const contentType = req.headers.get("content-type") || "";

    if (contentType.includes("application/json")) {
      return await req.json();
    } else if (contentType.includes("application/x-www-form-urlencoded")) {
      const formData = await req.formData();
      const data: Record<string, string> = {};
      for (const [key, value] of formData.entries()) {
        data[key] = value.toString();
      }
      return data;
    }
  } catch (error) {
    console.error("Failed to parse request data:", error);
  }

  return {};
}

// Substitute variables in command strings
function substituteCommands(
  commands: string[],
  data: Record<string, string>,
): string[] {
  return commands.map((cmd) => {
    let result = cmd;
    for (const [key, value] of Object.entries(data)) {
      result = result.replace(new RegExp(`\\$${key}\\b`, "g"), value);
      result = result.replace(new RegExp(`\\$\\{${key}\\}`, "g"), value);
    }
    return result;
  });
}

// Main request handler
async function handleRequest(
  req: Request,
  config: ServerConfig,
): Promise<Response> {
  const url = new URL(req.url);
  const path = url.pathname;
  const method = req.method;

  console.log(`${new Date().toISOString()} - ${method} ${path}`);

  // Find matching route
  const route = config.routes.find(
    (r) => r.path === path && r.method === method,
  );

  if (!route) {
    return new Response(JSON.stringify({ error: "Route not found" }), {
      status: 404,
      headers: { "content-type": "application/json" },
    });
  }

  // Parse request data
  const requestData = await parseRequestData(req);

  // Validate required data fields
  if (route.data) {
    for (const [key, type] of Object.entries(route.data)) {
      if (!(key in requestData)) {
        return new Response(
          JSON.stringify({ error: `Missing required field: ${key}` }),
          {
            status: 400,
            headers: { "content-type": "application/json" },
          },
        );
      }

      // Basic type validation
      if (type === "string" && typeof requestData[key] !== "string") {
        return new Response(
          JSON.stringify({ error: `Field ${key} must be a string` }),
          {
            status: 400,
            headers: { "content-type": "application/json" },
          },
        );
      }
    }
  }

  // Substitute variables in command strings
  const finalCommands = substituteCommands(route.command, requestData);

  // Execute commands sequentially
  const result = await executeCommands(finalCommands);

  const responseData = {
    success: result.success,
    outputs: result.outputs,
    errors: result.errors,
    commands: finalCommands,
  };

  return new Response(JSON.stringify(responseData), {
    status: result.success ? 200 : 500,
    headers: { "content-type": "application/json" },
  });
}

// Main server function
async function main() {
  const config = await loadConfig();

  console.log(`Starting LAN server on port ${config.port}`);
  console.log(`Configured routes:`);
  config.routes.forEach((route) => {
    console.log(`  ${route.method} ${route.path}:`);
    route.command.forEach((cmd, i) => {
      console.log(`    ${i + 1}. ${cmd}`);
    });
  });

  Deno.serve(
    {
      port: config.port,
      hostname: "0.0.0.0",
    },
    (req) => handleRequest(req, config),
  );
}

if (import.meta.main) {
  main();
}

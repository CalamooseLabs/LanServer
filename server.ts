#!/usr/bin/env -S deno run --allow-read --allow-run --allow-net

interface RouteConfig {
  path: string;
  method: string;
  command: string[];
  data?: Record<string, string>;
}

interface ServerConfig {
  port: number;
  runAsRoot: boolean;
  routes: RouteConfig[];
}

// Load configuration from JSON file generated by NixOS
async function loadConfig(): Promise<ServerConfig> {
  try {
    const configText = await Deno.readTextFile("/etc/lanserver/config.json");
    return JSON.parse(configText);
  } catch (error) {
    console.error("Failed to load config:", error);
    Deno.exit(1);
  }
}

// Execute command with proper error handling
async function executeCommand(command: string[], env: Record<string, string> = {}): Promise<{ success: boolean; output: string; error: string }> {
  try {
    const cmd = new Deno.Command(command[0], {
      args: command.slice(1),
      env: { ...Deno.env.toObject(), ...env },
      stdout: "piped",
      stderr: "piped",
    });

    const { code, stdout, stderr } = await cmd.output();

    return {
      success: code === 0,
      output: new TextDecoder().decode(stdout),
      error: new TextDecoder().decode(stderr),
    };
  } catch (error) {
    return {
      success: false,
      output: "",
      error: `Command execution failed: ${error.message}`,
    };
  }
}

// Parse request body for POST requests
async function parseRequestData(req: Request): Promise<Record<string, string>> {
  if (req.method !== "POST" || !req.body) {
    return {};
  }

  try {
    const contentType = req.headers.get("content-type") || "";

    if (contentType.includes("application/json")) {
      return await req.json();
    } else if (contentType.includes("application/x-www-form-urlencoded")) {
      const formData = await req.formData();
      const data: Record<string, string> = {};
      for (const [key, value] of formData.entries()) {
        data[key] = value.toString();
      }
      return data;
    }
  } catch (error) {
    console.error("Failed to parse request data:", error);
  }

  return {};
}

// Substitute variables in command
function substituteCommand(command: string[], data: Record<string, string>): string[] {
  return command.map(cmd => {
    let result = cmd;
    for (const [key, value] of Object.entries(data)) {
      result = result.replace(new RegExp(`\\$${key}\\b`, 'g'), value);
      result = result.replace(new RegExp(`\\$\\{${key}\\}`, 'g'), value);
    }
    return result;
  });
}

// Main request handler
async function handleRequest(req: Request, config: ServerConfig): Promise<Response> {
  const url = new URL(req.url);
  const path = url.pathname;
  const method = req.method;

  console.log(`${new Date().toISOString()} - ${method} ${path}`);

  // Find matching route
  const route = config.routes.find(r => r.path === path && r.method === method);

  if (!route) {
    return new Response(
      JSON.stringify({ error: "Route not found" }),
      { 
        status: 404,
        headers: { "content-type": "application/json" }
      }
    );
  }

  // Parse request data
  const requestData = await parseRequestData(req);

  // Validate required data fields
  if (route.data) {
    for (const [key, type] of Object.entries(route.data)) {
      if (!(key in requestData)) {
        return new Response(
          JSON.stringify({ error: `Missing required field: ${key}` }),
          { 
            status: 400,
            headers: { "content-type": "application/json" }
          }
        );
      }

      // Basic type validation
      if (type === "string" && typeof requestData[key] !== "string") {
        return new Response(
          JSON.stringify({ error: `Field ${key} must be a string` }),
          { 
            status: 400,
            headers: { "content-type": "application/json" }
          }
        );
      }
    }
  }

  // Substitute variables in command
  const finalCommand = substituteCommand(route.command, requestData);

  // Execute command
  const result = await executeCommand(finalCommand);

  const responseData = {
    success: result.success,
    output: result.output,
    error: result.error,
    command: finalCommand,
  };

  return new Response(
    JSON.stringify(responseData),
    {
      status: result.success ? 200 : 500,
      headers: { "content-type": "application/json" }
    }
  );
}

// Main server function
async function main() {
  const config = await loadConfig();

  console.log(`Starting LAN server on port ${config.port}`);
  console.log(`Configured routes:`);
  config.routes.forEach(route => {
    console.log(`  ${route.method} ${route.path} -> ${route.command.join(' ')}`);
  });

  Deno.serve({
    port: config.port,
    hostname: "0.0.0.0",
  }, (req) => handleRequest(req, config));
}

if (import.meta.main) {
  main();
}

